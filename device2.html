<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Device 2 - Air Quality Monitor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
    />
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-firestore-compat.js"></script>
    <script>
      const firebaseConfig = {
        apiKey: "AIzaSyBawdAvivw24kEJJcZ8pjOVKLnUCPlWxig",
        authDomain: "project-aqi-43620.firebaseapp.com",
        projectId: "project-aqi-43620",
        storageBucket: "project-aqi-43620.appspot.com",
        messagingSenderId: "853048957452",
        appId: "1:853048957452:web:51b30fd41cab4658cdec29",
        measurementId: "G-MVKRVKVVB0",
      };
      const app = firebase.initializeApp(firebaseConfig);
      const db = firebase.firestore();
      const auth = firebase.auth();

      const socket = io("http://localhost:10000");

      document.addEventListener("DOMContentLoaded", function () {
        // Real-time listener for location updates
        db.collection("devices").doc("device2").onSnapshot((doc) => {
          if (doc.exists) {
            const location = doc.data().location;
            document.querySelector(".device2-location").textContent = location || "Not Set";
          } else {
            console.log("No such document!");
          }
        }, (error) => {
          console.error("Error listening to device2:", error);
        });

        document.getElementById("logoutBtn").addEventListener("click", async (e) => {
          e.preventDefault();
          if (confirm("Are you sure you want to logout?")) {
            try {
              const logoutBtn = document.getElementById("logoutBtn");
              logoutBtn.innerHTML =
                '<i class="fas fa-spinner fa-spin mr-2"></i> Logging out...';

              await auth.signOut();
              localStorage.removeItem("user");
              window.location.href = "signin.html";
            } catch (error) {
              console.error("Logout error:", error);
              alert("Logout failed. Please try again.");
            }
          }
        });
      });

      // Initialize charts
      let pmChart, gasChart;
      let aqiChart, tempChart, humidityChart;

      function createGaugeOption(name, value, max) {
        return {
          series: [
            {
              name: name,
              type: "gauge",
              startAngle: 180,
              endAngle: 0,
              min: 0,
              max: max,
              splitNumber: 5,
              axisLine: {
                lineStyle: {
                  width: 10,
                  color: [
                    [0.3, "#10B981"],
                    [0.6, "#F59E0B"],
                    [1, "#EF4444"],
                  ],
                },
              },
              pointer: {
                length: "70%",
                width: 6,
              },
              detail: {
                formatter: "{value}",
                fontSize: 24,
                color: "#111827",
              },
              data: [{ value: value, name: name }],
            },
          ],
        };
      }

      function initCharts() {
        // PM Chart
        const pmCtx = document.getElementById("pmChart").getContext("2d");
        pmChart = new Chart(pmCtx, {
          type: "line",
          data: {
            labels: generateTimeLabels("1d"),
            datasets: [
              createDataset("PM1 (µg/m³)", "#EF4444", []),
              createDataset("PM2.5 (µg/m³)", "#F59E0B", []),
              createDataset("PM10 (µg/m³)", "#10B981", []),
            ],
          },
          options: createChartOptions("Particulate Matter (µg/m³)"),
        });

        // Combined Gas Chart
        const gasCtx = document.getElementById("gasChart").getContext("2d");
        gasChart = new Chart(gasCtx, {
          type: "line",
          data: {
            labels: generateTimeLabels("1d"),
            datasets: [
              createDataset("CO (ppm)", "#EF4444", []),
              createDataset("NO₂ (ppb)", "#8B5CF6", []),
            ],
          },
          options: createChartOptions("Concentration"),
        });

        // Gauge Charts with ECharts
        aqiChart = echarts.init(document.getElementById("aqiGauge"));
        tempChart = echarts.init(document.getElementById("tempGauge"));
        humidityChart = echarts.init(document.getElementById("humidityGauge"));

        aqiChart.setOption(createGaugeOption("AQI", 0, 500));
        tempChart.setOption(createGaugeOption("Temperature", 0, 50));
        humidityChart.setOption(createGaugeOption("Humidity", 0, 100));
      }

      async function updateCharts(range) {
        // Construct Flux query based on selected range
        let rangeDuration = '';
        switch (range) {
          case '5m':
            rangeDuration = '5m';
            break;
          case '30m':
            rangeDuration = '30m';
            break;
          case '1h':
            rangeDuration = '1h';
            break;
          case '12h':
            rangeDuration = '12h';
            break;
          default:
            rangeDuration = '1h';
        }

        // Flux query to fetch air_quality data for device2 in the selected time range
        const fluxQuery = `
          from(bucket: "aqi_project")
            |> range(start: -${rangeDuration})
            |> filter(fn: (r) => r._measurement == "air_quality" and r.device == "device2")
            |> pivot(rowKey:["_time"], columnKey: ["_field"], valueColumn: "_value")
            |> keep(columns: ["_time", "CO", "NO2", "Temperature", "Humidity", "PM1_0", "PM2_5", "PM10"])
            |> sort(columns: ["_time"])
        `;

        try {
          const response = await fetch('/query', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/vnd.flux',
            },
            body: fluxQuery,
          });

          if (!response.ok) {
            console.error('Failed to fetch data:', response.statusText);
            return;
          }

          const csvText = await response.text();
          const parsedData = parseCSVData(csvText);

          // Only update charts if data is valid and non-empty
          if (parsedData && parsedData.pm1.length > 0) {
            updateChartsWithRealData(parsedData);
          } else {
            console.warn('No data available for the selected range.');
          }
        } catch (error) {
          console.error('Error fetching data:', error);
        }
      }

      // Parse CSV data returned from InfluxDB query into chart data format
      function parseCSVData(csvText) {
        const lines = csvText.trim().split('\n');
        const headers = lines[0].split(',');

        // Initialize arrays for each data field
        const pm1 = [];
        const pm2_5 = [];
        const pm10 = [];
        const co = [];
        const no2 = [];
        const temperature = [];
        const humidity = [];

        // Parse each line after header
        for (let i = 1; i < lines.length; i++) {
          const values = lines[i].split(',');

          // Map columns by header index
          const timeIndex = headers.indexOf('_time');
          const coIndex = headers.indexOf('CO');
          const no2Index = headers.indexOf('NO2');
          const tempIndex = headers.indexOf('Temperature');
          const humIndex = headers.indexOf('Humidity');
          const pm1Index = headers.indexOf('PM1_0');
          const pm2_5Index = headers.indexOf('PM2_5');
          const pm10Index = headers.indexOf('PM10');

          // Push values or 0 if missing
          pm1.push(parseFloat(values[pm1Index]) || 0);
          pm2_5.push(parseFloat(values[pm2_5Index]) || 0);
          pm10.push(parseFloat(values[pm10Index]) || 0);
          co.push(parseFloat(values[coIndex]) || 0);
          no2.push(parseFloat(values[no2Index]) || 0);
          temperature.push(parseFloat(values[tempIndex]) || 0);
          humidity.push(parseFloat(values[humIndex]) || 0);
        }

        // Filter out any NaN or invalid values from arrays
        function filterValid(arr) {
          return arr.filter((v) => !isNaN(v) && v !== null);
        }

        return {
          pm1: filterValid(pm1),
          pm2_5: filterValid(pm2_5),
          pm10: filterValid(pm10),
          co: filterValid(co),
          no2: filterValid(no2),
          temperature: filterValid(temperature),
          humidity: filterValid(humidity),
          aqi: pm2_5.length > 0 ? calculateAQI(pm2_5[pm2_5.length - 1]) : 0,
        };
      }

      // New function to update charts with real data
      function updateChartsWithRealData(data) {
        // Update PM Chart
        const labels = generateTimeLabels("1d"); // or use timestamps from data if available
        pmChart.data.labels = labels;
        pmChart.data.datasets[0].data = data.pm1 || [];
        pmChart.data.datasets[1].data = data.pm2_5 || [];
        pmChart.data.datasets[2].data = data.pm10 || [];
        pmChart.update();

        // Update Gas Chart
        gasChart.data.labels = labels;
        gasChart.data.datasets[0].data = data.co || [];
        gasChart.data.datasets[1].data = data.no2 || [];
        gasChart.update();

        // Update gauges
        aqiChart.setOption({
          series: [{ data: [{ value: data.aqi || 0, name: "AQI" }] }],
        });
        tempChart.setOption({
          series: [{ data: [{ value: data.temperature || 0, name: "Temperature" }] }],
        });
        humidityChart.setOption({
          series: [{ data: [{ value: data.humidity || 0, name: "Humidity" }] }],
        });
      }

      // Listen for real-time data from socket.io
      socket.on("newDataDevice2", (data) => {
        // Data received: { deviceId, co, no2, temperature, humidity, pm1_0, pm2_5, pm10 }
        // Prepare data arrays or single values for charts
        const realData = {
          pm1: [parseInt(data.pm1_0)],
          pm2_5: [parseInt(data.pm2_5)],
          pm10: [parseInt(data.pm10)],
          co: [parseFloat(data.co)],
          no2: [parseFloat(data.no2)],
          aqi: calculateAQI(data.pm2_5), // Implement AQI calculation or use pm2_5 as proxy
          temperature: parseFloat(data.temperature),
          humidity: parseFloat(data.humidity),
        };
        updateChartsWithRealData(realData);
      });

      // Simple AQI calculation placeholder
      function calculateAQI(pm25) {
        if (!pm25) return 0;
        const val = parseFloat(pm25);
        if (val <= 12) return 50;
        if (val <= 35.4) return 100;
        if (val <= 55.4) return 150;
        if (val <= 150.4) return 200;
        if (val <= 250.4) return 300;
        return 400;
      }

      function getColorForValue(percent) {
        if (percent < 0.3) return "#10B981"; // Green
        if (percent < 0.6) return "#F59E0B"; // Yellow
        return "#EF4444"; // Red
      }

      function createDataset(label, color, data) {
        return {
          label,
          data,
          borderColor: color,
          backgroundColor: color + "20",
          borderWidth: 2,
          tension: 0.3,
          fill: true,
        };
      }

      function createChartOptions(title) {
        return {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: title,
              },
            },
            x: {
              title: {
                display: true,
                text: "Time",
              },
            },
          },
        };
      }

      function generateTimeLabels(range) {
        const now = new Date();
        let labels = [];
        let count = 24; // Default for 1 day

        if (range === "7d") count = 7;
        if (range === "14d") count = 14;
        if (range === "1m") count = 30;

        for (let i = count; i >= 0; i--) {
          const date = new Date(now);
          if (range === "1d") {
            date.setHours(now.getHours() - i);
            labels.push(date.getHours() + ":00");
          } else {
            date.setDate(now.getDate() - i);
            labels.push(date.toLocaleDateString());
          }
        }
        return labels;
      }

      // Initialize charts when page loads
      window.onload = initCharts;
    </script>
</body>
</html>
